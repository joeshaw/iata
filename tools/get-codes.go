package main

import (
	"encoding/csv"
	"fmt"
	"io"
	"log"
	"os"
	"strings"
)

func main() {
	in, err := os.Open(os.Args[1])
	if err != nil {
		log.Fatal(err)
	}
	defer in.Close()

	out, err := os.Create(os.Args[2])
	if err != nil {
		log.Fatal(err)
	}
	defer out.Close()

	r := csv.NewReader(in)

	var (
		iatas []string
		seen  = make(map[string]struct{})
	)

	fmt.Fprint(out, header)
	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}

		if err != nil {
			log.Fatal(err)
		}

		icao, typ, name, country, region, city, iata := rec[0], rec[1], rec[2], rec[5], rec[6], rec[7], rec[9]

		// Skip the header line
		if iata == "iata_code" {
			continue
		}

		// Skip closed airports
		if typ == "closed" {
			continue
		}

		switch country {
		case "US", "CA":
			if len(region) > 3 {
				prov := region[3:]
				city += ", " + prov
			}
		}

		fmt.Fprintf(
			out,
			"`%s`: { iata: `%s`, icao: `%s`, name: `%s`, city: `%s`, country: `%s` },\n",
			icao,
			iata, icao, escapeBackticks(name), escapeBackticks(city), country,
		)

		if iata != "" && iata != icao {
			if _, ok := seen[iata]; !ok {
				iatas = append(iatas, fmt.Sprintf(
					"`%s`: { iata: `%s`, icao: `%s`, name: `%s`, city: `%s`, country: `%s` },\n",
					iata,
					iata, icao, escapeBackticks(name), escapeBackticks(city), country,
				))
				seen[iata] = struct{}{}
			}
		}
	}

	fmt.Fprint(out, midpoint)
	for _, entry := range iatas {
		fmt.Fprintf(out, entry)
	}
	fmt.Fprint(out, footer)

	if out.Close(); err != nil {
		log.Fatal(err)
	}
}

func escapeBackticks(s string) string {
	return strings.ReplaceAll(s, "`", "` + \"`\" + `")
}

const header = `// Generated by tools/get-codes.go
package main

type airport struct {
	iata, icao, name, city, country string
}

var icaos = map[string]airport {
`

const midpoint = `}

var iatas = map[string]airport {
`

const footer = `}`
