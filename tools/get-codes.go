package main

import (
	"encoding/csv"
	"fmt"
	"io"
	"log"
	"os"
	"sort"
	"strings"
)

func main() {
	in, err := os.Open(os.Args[1])
	if err != nil {
		log.Fatal(err)
	}
	defer in.Close()

	out, err := os.Create(os.Args[2])
	if err != nil {
		log.Fatal(err)
	}
	defer out.Close()

	r := csv.NewReader(in)

	var entries [][]interface{}

	for {
		rec, err := r.Read()
		if err == io.EOF {
			break
		}

		if err != nil {
			log.Fatal(err)
		}

		icao, name, country, region, city, iata := rec[1], rec[3], rec[8], rec[9], rec[10], rec[13]

		// Skip the header line and skip airports with no (or
		// garbage) IATA codes
		if iata == "iata_code" || iata == "" || iata == "0" || iata[0] == '-' {
			continue
		}

		switch country {
		case "US", "CA":
			if len(region) > 3 {
				prov := region[3:]
				city += ", " + prov
			}
		}

		entries = append(entries, []interface{}{iata, icao, escapeBackticks(name), escapeBackticks(city), country})
	}

	sort.Slice(entries, func(i, j int) bool {
		return entries[i][0].(string) < entries[j][0].(string)
	})

	fmt.Fprint(out, header)
	for _, entry := range entries {
		fmt.Fprintf(
			out,
			"{ iata: `%s`, icao: `%s`, name: `%s`, city: `%s`, country: `%s`},\n",
			entry...,
		)
	}
	fmt.Fprint(out, footer)

	if out.Close(); err != nil {
		log.Fatal(err)
	}
}

func escapeBackticks(s string) string {
	return strings.ReplaceAll(s, "`", "` + \"`\" + `")
}

const header = `// Generated by tools/get-codes.go
package main

type airport struct {
	iata, icao, name, city, country string
}

var airports = []airport {
`

const footer = `}`
